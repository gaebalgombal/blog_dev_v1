# 꼼꼼하게 에러를 핸들링했습니다

## 🙌 유저를 붙잡는 에러 핸들링

에러 핸들링의 엔드 포인트는 ‘유저'다. 에러 핸들링의 궁극적인 목적은 유저에게 적절한 가이드를 주고, 유저가 계속해서 서비스를 이용할 수 있도록 하는 것이다. 프런트는 에러 종류별로 유저에게 적절한 가이드를 줘야 한다.

이런 관점에서, 에러를 이렇게 분류하고 적절한 대처 방법을 찾아봤었다. [_유저를 붙잡는 에러 핸들링 >>_](https://www.notion.so/31f52934bd9342a1b68901fc8d987ce2?pvs=21)

![error_handling](../../references/draft/2022.11_transportation/error_handling/errors.png)

그런데, ‘백엔드 개발자'로서는 에러 핸들링을 어떻게 해야 할까?

이번 프로젝트를 하면서 그 부분도 다시 정리해보았다.

## 🙌 에러 핸들링에서 서버의 역할은 무엇일까?

에러 핸들링의 엔드 포인트는 유저다. 클라이언트에서 유저에게 적절한 가이드를 주고, 유저가 계속해서 서비스를 이용할 수 있도록 하는 것이다. 그렇다면 일련의 에러 핸들링 과정에서 서버는 무슨 역할을 해야 할까?

1. **클라이언트의 요청을 검증한다.**

   서버는 클라이언트에서 요청하는 정보를 꼼꼼하게 검증하고, 에러여부를 확인한다.

2. **요청을 검증하고, 에러를 구분하여 HTTP 상태코드와 에러 메세지를 지정, 클라이언트에 반환한다.**

   클라이언트가 유저에게 가이드를 제공하려면, 에러의 내용을 알아야 한다. 따라서, 서버는 클라이언트의 요청을 꼼꼼하게 검증하고, 에러가 있을 경우 프런트에게 에러의 내용 - HTTP 상태 코드와 에러 메세지를 - 를 클라이언트에 반환한다. 클라이언트는 서버가 보내온 에러의 내용을 기반으로 유저에게 가이드를 제공한다.

   1. 바디의 데이터를 꼼꼼하게 검증한다.
      - 데이터의 제약 조건을 검증한다. ex. null, unique, 길이, 자료형 등
      - 비즈니스 로직에 따른 조건을 검증한다. ex. 계정명 규칙, 비밀번호 규칙 등
   2. 헤더의 정보를 검증한다.

      ex. 헤더의 Authorization에 따른 인증•인가 검증, 메서드 종류에 따른 검증 등

3. **보안상 위험을 방어한다.**

   또 한 가지 중요한 역할은 보안이다. 클라이언트 ↔ 서버 간의 통신에 따라 발생할 수 있는 보안상 허점을 꼼꼼하게 방어한다.

   ex. cors 설정, 토큰의 유효 기간 설정 등

4. **서드 파티에 관련된 에러를 핸들링한다**

   서드 파티를 사용할 경우, 서버는 다른 서드 파티의 ‘클라이언트'가 된다. 이 때 서버는 클라이언트로서의 에러 핸들링 - 요청, 응답 결과에 따른 예외 처리 - 등을 담당해야 한다.

5. **로깅과 모니터링 시스템을 갖춘다.**

   예상하지 못한 장애가 발생했거나, 발생할 위험이 있을 경우, 이를 발견하고 고칠 수 있도록 해야 한다.

## 🙌 구체적으로 어떤 에러를, 어떻게 핸들링했는가?

프로젝트를 진행하면서 위와 같은 에러 핸들링 작업을 꼼꼼하게 하려고 했다.

1. **정확한 상태코드의 지정**

   먼저, 에러 종류에 따라 정확하게 상태 코드를 지정하여 반환했다.

   상태 코드를 400, 500처럼 두루뭉술하게 할 경우, 프런트는 상태를 정확하게 알지 못하거나, 알더라도 에러를 잡아내기 위해 코드를 지저분하게 짜야 한다.

   그래서 최대한 세분화해서 정확하게 상태 코드를 지정하려 했다.

| 요청의 구조 | 항목                      | 무슨 에러를 검증해야 하나?                                                 | 상태코드 |
| ----------- | ------------------------- | -------------------------------------------------------------------------- | -------- |
| Method      | -                         | 이 path에서 허용된 메소드가 아닐 경우                                      | 405      |
| URL         | path                      | 이 path에 리소스(페이지)가 존재하지 않을 경우                              | 404      |
|             | query param, path param   | 파라미터로 필터링을 걸어 조회했을 때, 데이터가 존재하지 않을 경우          | 404      |
| Headers     | Authorization, Set-cookie | 인증 오류(우리 서비스의 유저가 아닐 경우)                                  | 401      |
|             | Authorization, Set-cookie | 인가 오류(유저가 이 기능에 대한 접근 권한을 가지고 있지 않을 경우)         | 403      |
|             | Content-type              | 바디의 형식이, content-type과 일치하지 않는 경우                           | 415      |
|             | Accept                    | accept 형식에 알맞는 서버 데이터가 존재하지 않아, 응답에 담을 수 없는 경우 | 406      |
| Body        | 데이터                    | POST/PUT할 때, 데이터가 DB 제약 조건에 걸리는가?                           | 400      |
|             | 데이터                    | POST/PUT할 때, 데이터가 비즈니스 로직 조건에 걸리는가?                     | 400      |
|             | 데이터                    | GET/DELETE할 때, 데이터가 존재하지 않을 경우                               | 404      |
| •••         | •••                       | •••                                                                        | •••      |

1. **보안 설정**

   시키는 대로 단순 기능 구현을 하면, 프레임워크를 구멍이 숭숭 뚫린 채로 사용하게 된다.

   또한, http 스펙과 웹 서비스의 흐름을 이해하고 프레임워크의 보안 설정을 꼼꼼하게 했다.

| 보안 설정                              | 어떤 위험이 있나?                                           | 어떻게 방어하나?                                                       |
| -------------------------------------- | ----------------------------------------------------------- | ---------------------------------------------------------------------- |
| cors의 구체적이고 안전한 설정          | 악의적인 출처에서 요청이 들어올 위험                        | 와일드카드(x), 안전하고 꼭 필요한 출처들만 구체적으로 명시             |
| allowed hosts의 구체적이고 안전한 설정 | 악의적인 출처에서 요청이 들어올 위험                        | 와일드카드(x), 안전하고 꼭 필요한 출처들만 구체적으로 명시             |
| JWT 취약성 보완                        | 토큰을 공격자가 탈취하여, 개인 정보를 요청할 위험           | 토큰의 유효 기간을 짧게 설정, 블랙리스트 앱 활용                       |
| pk 대신 uuid의 활용                    | 주요 정보인 pk를 탈취, 취약점을 공격할 위험                 | pk 대신 추측이 어려운 uuid로 대체                                      |
| 보안 키 안전하게 보관하기              | github등을 공격해 보안 키 획득, 서버에 마음대로 접근할 위험 | 절대 github에 노출시키지 않고 랩핑하기                                 |
| 사용자가 올린 파일 안전하게 다루기     | 파일이 악의적 공격을 담고 있을 위험                         | 안전한 서드 파티 저장소(ex. s3) 사용                                   |
| https 기반으로 만들기                  | 보안이 약한 http를 통해 공격할 위험                         | 모든 페이지, 특히 이미지 페이지 등 간과하기 쉬운 부분까지 https로 설계 |
| •••                                    | •••                                                         | •••                                                                    |

## 🙌 에러 핸들링을 개선해보자

1. **프레임워크를 최대한 활용하자**

   프레임워크를 적절하게 활용하면, 하나하나 신경써야 했던 예외 처리를 프레임워크가 알아서 해준다. 심지어는 내가 생각하지 못한 부분까지 기본적인 부분은 모두 예외 처리를 해준다.

   ex. serializer 객체 활용

   serializer은 요청의 body ↔ DB의 데이터로 직렬화/역직렬화 역할을 해주는 도구로, 장고에서 지원하는 객체다. serializer은, 상황별, 에러별로 http 상태 코드를 알아서 지정하여 반환해준다. 따라서 하나하나 try-catch로 예외처리를 해주지 않아도 되기 때문에 생산성이 높고, 동시에 안전하다.

1. **모든 에러를 예외처리할 필요는 없다**

   처음에는 모든 에러를 완벽하게 처리하고, 데이터 정합성을 완벽하고 엄격하게 지키려고 노력했는데, 프로젝트를 하면서 그것이 어려운 상황에 부딪혔다.

   ex. 이미지를 s3에 저장하고, DB 이미지 테이블에 url을 저장할 때,

   s3와 이미지테이블을 하나의 트랜잭션으로 묶어 데이터 정합성을 유지할 필요가 있을까?

   에러로 인해, 이미지를 삭제할 때, 만약 DB 테이블의 url은 삭제되었는데, s3에는 이미지가 남아있다면?

   물론 데이터 정합성에는 문제가 생긴다. 하지만 어차피 유저에게 보여지는 결과에는 달라지는 것이 없다. (DB에서 삭제되었다면 어차피 접근이 불가능하다.) 그렇다면, 당장 에러를 터뜨려 유저에게 불편함을 주는 것보다, 지연하여 처리하는 것이 좋을 것이라 판단했다. 그래서 s3에 대한 에러를 적절하게 넘기고, 이후 서버 스케쥴링 등을 통해 정합성을 확보하는 방향으로 설계했다.
