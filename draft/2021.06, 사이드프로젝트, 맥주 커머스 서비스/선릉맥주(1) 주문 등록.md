# 선릉맥주(1) 주문 등록

**2001년 6월 19일2001년 6월 19일**

**Written By [anne shirley](https://www.todayitanzada.com/?author=600ccc46fca7d614a7dbe498)**

- **무엇을 했나**
  - 프로젝트 명: 선릉맥주(제주맥주 클론 프로젝트)
  - 구현한 기능: 상품 리스트 GET, 주문 POST
- **무엇을 배웠나**
  - 항상 큰 그림을 보자
  - 코딩은, 논리의 흐름을 개발 언어로 ‘번역’하는 것이다.
  - 데이터가 꼭 Unique해야 할까? Unique 하지 않아도 되지 않을까? 한번 더 생각해보자

2주 동안, 선릉 맥주 프로젝트를 진행하며, 상품 리스트 GET과 주문 POST 맡아 구현하였다.

이 포스트에서는 ‘주문 POST’에 대해 구현하는 과정과, 부족했던 부분, 다음 프로젝트 때 개선할 부분을 정리해보려고 한다.

1. 주문 POST에 오기까지의 프로세스 정립
2. 주문 POST 과정 구현
3. 왜 더 좋은 코드를 생각하지 못했을까? & 다음에 좋은 코드를 쓰려면 어떻게 생각해야 할까?

- - 개발 클론이 아닌 ‘기획 클론’

선릉맥주 프로젝트는 제주맥주 클론 프로젝트이지만, 백지 상태에서 구현되었습니다.

개발자의 역할은 기획이 아닌, 기획 의도를 현실로 바꾸는, 기획의 ‘구현’이라 생각합니다.

따라서, 기획 과정을 건너 뛰고 구현에 집중하기 위해 제주맥주라는 서비스를 참고한 것일 뿐,

프로젝트의 모든 기능은, 실제 서비스 개발과정과 마찬가지로, 백지 상태에서 구현되었음을 밝힙니다.

**1.주문 POST에 오기까지의 프로세스 정립**

유저 입장에서, 주문을 하는 방법은 2가지가 있다. 우리는 이 2가지 프로세스를 모두 구현해야 했다.

1. 장바구니에서 주문
2. 상품 상세에서 주문

개발 관점에서, 이 2가지를 모두 포함하는 프로세스를 구현하는 방법도 여러가지가 있었다.

- 어떤 경우든 ‘장바구니 등록패치’를 거치도록 하는 방법
  바로 주문/장바구니 주문 : 장바구니 등록 패치 >> 주문 등록 패치
- 바로 주문은 바로 결제패치로 오도록 하는 방법
  장바구니 주문: 장바구니 등록 패치 >> ( 장바구니 조회) >> 주문 등록 패치
  바로 주문: 주문 등록 패치

우리는 전자를 택했는데, 모든 주문의 프로세스가 일관성있게 같은 프로세스를 거치게 하기 위해서였다.

즉, 주문을 할 경우, 일단 주문 전(장바구니) 상태로 아이템이 등록 되고, 그 후 실제 주문을 하면 아이템의 상태만 주문완료로 바뀌도록(정확히는 주문완료 상태인 주문으로 연결이 변경되도록) 하는 프로세스.

다만, 바로 주문일 경우, ‘장바구니 조회’를 거치지 않기 때문에, 주문 등록 패치 단계에서 OrderItem의 ID를 보내줄 수가 없었다.

따라서 ‘장바구니 등록’ 단계에서 등록 완료 후 응답에 OrderItem을 담아 반환하기로 했다.

장바구니 주문: >>장바구니 등록 (OrderItem ID 반환) >> (장바구니 조회(Order Item ID 반환) >> 주문 등록(OrderItem ID 받아 조작)

바로 주문: 장바구니 등록(OrderItem ID 반환) >> 주문 등록(Order Item ID 받아 조작

**2. 주문 POST 과정 구현**

이제, 진짜 주문 POST 단계에 들어왔다. 주문 POST 과정을 구현해보자.

1. 감귤을 주문해보자.

   유저 관점: 감귤을 주문한다.

   개발 관점: 새로운 Order ( OrderStatus 주문완료) 데이터를 생성한 뒤, 감귤 OrderItem 데이터의 PK를 기존의 Order(OrderStatus 장바구니)에서 방금 생성한 Order으로 바꿔준다.

   - 왜 기존 장바구니 Order의 상태를 바꾸는 것이 아니라, 별도의 새로운 Order를 생성했을까?
     장바구니의 모든 아이템을 주문하는 것이 아니기 때문이다.
     예를 들어, 장바구니에 감귤, 맥주, 초콜릿이 담겨있다고 해보자. 장바구니 Order에, 감귤 OrderItem, 맥주 OrderItem, 초콜릿 OrderItem이 연결되어 있을 것이다.
     그런데 유저가 그 중 ‘감귤’만 주문했다면?
     감귤이 연결된 ‘주문 완료’ Order 하나와, 맥주, 장바구니가 연결된 ‘장바구니’ Order이 각각 있어야 한다.
     그래서, 장바구는 그대로 두고, 감귤이 담긴 새로운 Order(Order Status 주문완료) 로 바꿔준 것이다.
   - 왜 OrderItem을 새로 생성하는 것이 아니라 PK를 바꿔줄까?
     어떤 주문 경로든, 무조건 ‘장바구니 등록’ 패치를 거쳐 ‘주문 등록’ 패치로 오기 때문에, 우리는 새로운 OrderItem을 생성하는 것이 아니라,
     ‘장바구니 등록 패치’에서 이미 등록된 OrderItem을 가지고 조작하면 된다.

2. 감귤을 바로 주문? 장바구니에서 주문?

   (2번이 안 써져 3번으로 넘어왔다ㅠㅠ squarespace 너무 어렵다..)

   그런데 문제가 있다. 주문 단계에서도 다시 바로주문/장바구니에서주문을 나눠주어야 한다는 것이다.

   예를 들어 보자. 유저A가 장바구니에 감귤을 3개를 담아두었는데, 방금 감귤 상세 페이지에서 2개를 ‘바로 주문’을 클릭했다면?

   감귤 2개가 주문되고, 장바구니에 감귤 3개가 그대로 담겨있어야 한다.

   만약 합쳐져서 감귤 5개가 주문되거나, 장바구니에서 감귤이 사라져버린다면, 유저A는 당황할 것이다.

   주말에 먹을 걸 장바구니에 담아두었는데, 갑자기 감귤이 너무 땡겨서 2개를 바로 주문한것이었다면…우리는 방금 유저의 주말 소확행을 뺏어버린 것일 수도 있다….(다시 담으면 되지만 아무튼)

   진지하게 말하자면 UX 관점에서 매우 이상하다. 유저가 인지한 것과 결과가 다르다.

   감귤 2개가 주문되고, 장바구니에 감귤 3개가 그대로 담겨있는 것이 맞다.

   이 논리를 개발 관점에서 보면 다음과 같다.

   새로운 Order에 연결된 감귤 2개 OrderItem과, 장바구니 Order에 연결된 감귤 3개 OrderItem이 각각 있어야 한다.

   문제는, 우리의 장바구니 등록 패치에서는, 장바구니에 이미 기존 아이템이 있는 경우, 해당 아이템에 수량이 합산되어 버리도록 구현되어 있다는 것이었다. ( 위의 예시에서는 5개로 구현)

   그리고 바로 주문은 장바구니 등록 >> 주문 등록 패치로 이어지므로, 무조건 감귤 5개로 합산되어 들어올 수 밖에 없다.

   이를 어떻게 구분해줘야 하는지 머리가 아파오기 시작했다.

3. 그럼 대체 어떻게 구현해야 하는 거지?

   그럼 대체 어떻게 구현하는게 좋을까? 내가 선택한 방법과, 문제점, 그리고 개선안을 이야기해보려 한다.

   1. 내가 선택한 방법

      내가 선택한 방법은, 프런트에서 ‘수량’을 별도로 받아, 주문 등록 단계에서 ‘수량’을 기준으로 경우의 수를 나눠 각각 처리하는 것이었다. (바로주문/장바구니주문)

      장바구니에서 주문하기일 경우, 프런트에서 들어온 수량이 무조건 OrderItem에 저장된 수량과 같을 수 밖에 없다.(장바구니 등록,수량변경 모두 즉시 저장되므로)

      반면, 바로 주문일 경우, 프런트에서 들어온 수량은 OrderItem에 저장된 수량과 다르다.

      (장바구니에 감귤 3개, 바로 주문 2개라면, 장바구니 등록 패치에서 3+2로 5개가 되었을 것이고, 주문하려는 2개와 수량이 다를 수 밖에 없다.)

      따라서, 저장된 수량과 프런트에서 들어온 수량이 같으면 장바구니 주문, 다르면 바로 주문이다.

      그리고 바로 주문인 경우에, OrderItem을 다시 해체(…) 하는 작업을 해줬다.

      위의 예시를 다시 가져와보면, 현재 장바구니 Order에 연결된 감귤 OrderItem의 수량이 5개로 되어 있다.

      이 아이템의 1) 수량은 3개로 다시 변경해주고, 2) 더불어 수량 2개의 감귤을 새로 생성하여 주문완료 Order에 연결

   2. 문제점

      하지만 이 방법은 매우 안 좋다! 그것이 결론. 장바구니 등록 패치에서 일부러 합친 다음에, 주문 패치에서 그걸 다시 나눠준다는 것인데, 당연히 했던 짓을 번복하는 쓸데없는 짓이다.

      하지만 난 마지막까지 이 굴레에서 벗어나지 못했다. 일단 개선안 이야기하고 왜 이 굴레에서 벗어나지 못했는지를 다시 고민해보자.

   3. 개선안

      애초에 장바구니 등록 패치에서, OrderItem을 따로 생성해주면 된다. 즉,

      - 장바구니 등록 패치

      1. 감귤 2개를 ‘장바구니 담기’를 클릭한 경우: 감귤 OrderItem 데이터를 새로 생성해준다. (PK 장바구니Order, ID 1번)
      2. 감귤 2개를 ‘장바구니 담기’에 클릭했는데, 장바구니에 이미 3개가 있었던 경우: 기존 감귤 OrderItem의 수량을 수정해서 저장한다. (PK 장바구니 Order, 3개 -> 5개, ID 1번)
      3. 감귤 2개를 ‘바로 주문하기’를 클릭한 경우: 별도의 감귤 OrderItem을 새로 생성해준다. (PK 장바구니Order, ‘ID 2번)

         > > 모두 Response에 OrderItem 담아서 반환

- 주문 패치

1. 장바구니 주문, 바로 주문: 아무 상관없음
2. 무조건 들어온 OrderItem에 대해, PK를 ‘장바구니 주문’에서 ‘새로 생성된 주문 완료 주문’으로 바꿔주기만 하면 된다.

**3. 왜 더 좋은 코드를 생각하지 못했을까? & 다음에 좋은 코드를 쓰려면 어떻게 해야 할까?**

- 큰 그림을 보자.
  ‘주문’ 프로세스의 큰 그림을 봐야 했다.
  주문 프로세스는, 상품 상세 페이지 >> 장바구니 등록 >> (장바구니 조회) >> 주문 등록이므로,
  전체 프로세스에서 최선의 방법을 생각해야 했는데, 내가 맡은 부분인 ‘주문 등록’만 생각하다보니, ‘합쳤다가 다시 나눴다가, 근데 나누는 것도 억지로 나눴다가’ 하는 그림이 나온 것 같다.
  다음 프로젝트 때에는 ‘전체 프로세스’라는 큰 그림을 두고 프로스세를 생각해야 겠다.
- 논리의 흐름을 그대로 개발 언어로 번역하자.
  사실 내가 작성한 방법이든, 개선안이든, 결과물은 똑같다.
  하지만 내가 작성한 방법보다 개선안이 훨씬 좋은 코드인 이유는 ‘논리적 흐름’에 따라 구현되었기 때문이다.
  “장바구니 등록 패치에서 OrderItem을 등록하고, 등록한 OrderItem의 ID를 반환해준다. >> 주문 등록 패치에서 새로운 Order를 생성하고, 들어온 OrderItem의 PK를 새 Order로 바꿔준다.”
  딱 이 논리가 고대로 개발 언어로 ‘번역’되었기 때문에, 누구나 이해할 수 있고, 이후 다른 기능이 고도화되거나 변경될 때도 어긋날 일이 없다.
  반면 내가 작성한 코드는 무슨 일이 벌어지고 있는 거지?? 싶고 남들이 볼 때 이해하기 어렵다.
  단순 기능 구현이 아니라 ‘팀원들이 이해할 수 있는‘ 기능 구현을 해야 한다.
- 데이터가 꼭 Unique해야 할까? Unique하지 않아도 되지 않을까? 한 번 더 생각해보자.
  끝까지 굴레에서 벗어나지 못했던 가장 큰 이유는 ‘하나의 Order에 연결된 Product는 Unique해야 한다’라는 생각에 집착했던 것이었다.
  그리고, 모든 데이터를 구분할 때는 일단 고유의 값인 ‘ID’로 구분하는 것을 전제로 먼저 생각해봐야 하는데, ‘수량’을 가지고 구분하려다보니 문제가 안 풀렸다. ( 물론 안 그런 경우도 있겠지만)
  즉, 장바구니 Order에 ‘감귤’ OrderItem이 2가지가 있을 수는 없다고 생각했다. 대체 왜 그렇게 생각했는지는 모르겠지만.
  어쨌든, 앞으로 문제가 안 풀릴 때
  “꼭 Unique 해야 할까? Unique 하지 않아도 되지 않을까?” 를 한 번 더 생각해보자.
  혹은,
  “ID 로 구분하려면 어떻게 해야 할까?”를 생각해보자.
  그러면 이번과 마찬가지로
  “ID 로 구분하려면 >> ID가 달라야 하니 >> 따로 따로 데이터를 만들어야 한다” 라고 답을 찾을 수 있을지도.

2차 프로젝트 때는 이번에 배운 것들을 생각하며 더 좋은 코드를 작성할 수 있었으면 좋겠다.
