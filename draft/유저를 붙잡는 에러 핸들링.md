# 유저를 붙잡는 에러 핸들링

## 🧐에러 핸들링, 왜 중요할까?

### 운영의 기본은 사고를 막는 것이다

이벤트를 기획할 때, 가장 중요한 것이 뭘까? 창의적인 컨셉? 탐나는 경품? 세련된 카피? 물론 이런 요소들도 중요하다. 그러나 가장 중요한 것은 어뷰징을 걸러내고 **문제없이 운영되도록 하는 것**이다. 아무리 세련된 카피와 재미있는 컨셉으로 눈길을 끌었다고 해도, 체리 피커들만 잔뜩 몰려온다면 허울 좋은 껍데기가 되어버린다. 그래서 기획을 할 때면 꼼꼼하게 기획하는데 가장 공을 많이 들였다. 어뷰징 당할 허점은 없을까? 있다면 어떻게 막을 수 있을까? 일부러 더 의심하고 꼼꼼하게 대책을 세웠다.

**현업의 기본은 문제 없이 운영되도록 하는 것**이라 생각한다. 기획, 운영, 개발, 전부 마찬가지다. 기획자라면 어뷰징이 생기지 않도록 시나리오를 짜야 하고, 운영이라면 꼼꼼하게 모니터링하고 CS를 관리해야 하며, 개발자라면 적절하게 에러를 핸들링해야 한다. 개발자의 책임은, 적절하게 에러를 핸들링하여 견고한 서비스를 구축하는 것이라 생각한다.

### 가게를 잘 운영하려면 손님을 붙잡아야 한다

운영의 기본은 문제 없이 운영하는 것이다. 가게를 잘 운영하려면, 손님이 가게를 불편하다면 나가버리지 않고, 계속 이용하도록 해야 한다. 아무리 맛있는 음식을 팔아도, 직원도, 메뉴판도 없어 음식을 시킬 수가 없다면 손님은 짜증을 내며 나가버릴 것이다. 사이트가 아무리 화려한 화면, 멋진 서비스로 가득해도 서버가 터지고, 오류가 계속 난다면, 유저는 짜증을 내며 나가버릴 것이다.

서비스를 잘 운영하려면, 유저를 붙잡아야 한다. 그러려면 안정적이고, 사용자에게 친절한 서비스를 만들어야 한다. 에러 핸들링이 중요한 이유 역시 여기 있다. 어쩌면 멋진 서비스를 만드는 것보다 불편함 없는 서비스를 만드는 것, 이를 위해 에러 핸들링을 잘하는 것이 더 중요할지도 모른다.

결국, **에러 핸들링의 목적은 유저를 붙잡아 두는 것**이다. **1)유저가 에러 없이 안정적으로 편하게 서비스를 계속 이용할 수 있게 하고, 2)혹시 오류가 발생해도 친절한 오류 메세지를 통해 서비스를 계속 이용할 수 있게 하는 것.**

- **유저를 가게에 붙잡아두자**
  **유저의 불편을 최소화해서 서비스에서 이탈하지 않게 하자**

그런데, 유저의 불편을 최소화하기 위해서는 어떻게 해야 할까? 음식점에 고객 대응 매뉴얼이 있는 것을 떠올려보자. 만약 음식이 다 떨어지면 주인은 “품절입니다. 다른 메뉴를 드릴까요?” 안내할 것이고, QR코드를 안 찍고 들어온다면 “QR 코드를 찍어주셔야 입장이 가능합니다.” 하고 안내할 것이다. 이처럼 서비스에서도 품절 상황(404), 입장 티켓이 없는 상황(401), 손님이 꽉 차서 자리가 없는 상황(트래픽 폭주) 등, 다양한 상황을 모두 리스트업하고 각각 대응책을 미리 마련해놔야 한다.

- **매뉴얼을 준비해놓자**
  **에러에 대해 미리 대처 방법을 준비하자**

마지막으로, 기록해야 한다. 어떤 문제-에러가 발생했는지, 어떻게 대응했는지, 혹은 대처하지 못하고 터져버렸는지, 얼마나 자주 발생하는지, 기록을 남겨놓아야 한다. 그래야 다음에 다시 대처할 수 있고, 혹시 이번에 대처하지 못해 유저가 문을 박차고 나가버렸더라도 고쳐서 다음에는 유저를 붙잡을 수 있다.

- **기록을 남겨놓자**
  **로그를 남기고, 계속 모니터링하자**

_(개발자로써의 경험은 아니지만, 실제로 이전 회사 프로젝트에서, 로그를 통해 서비스 취약점을 발견하고, 사고를 막은 경험이 있다. 개발팀은 로그를 슬랙에 연동하여 누구나 쉽게 모니터링 할 수 있는 시스템을 갖춰두었고, 나를 포함한 운영팀은 틈날때마다 모니터링을 할 수 있었다. 확률 이벤트에 대한 유저들의 당첨 기록 로그를 살펴보다가, 당첨 알고리즘에 어뷰징 요소가 있으며 특정 유저가 실제로 이를 악용하고 있다는 것을 발견할 수 있었다. 덕분에 긴급패치를 실시, 더 큰 손실을 막을 수 있었다. 이처럼 로그는 견고한 서비스를 만들기 위해 꼭 필요한 장치다.)_

## 🧐어떤 에러들이 있을까?

에러를 잘 핸들링 하기 위해서는 먼저 에러를 잘 알아야 한다.

검색해보면 에러와 예외처리에 대해 많은 좋은 글들을 찾아볼 수 있다. 다만 대부분의 글은 클라이언트 중심으로 에러를 분류하고, 또 에러↔ 대처가 잘 대응되지 않아 나름의 방식대로 에러를 다시 분류해봤다.

### 에러라고 다 같은 에러가 아니다.

우리는 ‘에러’라는 명칭을 혼용해서 사용하고 있다. 먼저, 에러를 구분해보자.

![where_are_errors](../references/draft/error_handling/where_are_errors.png)

- **운영상 예외 Operational Errors**
  ![bomb_1](../references/draft/error_handling/bomb_1.png)

  운영상 언제나 발생하는 여러 케이스들. 음식점에서 음식이 품절되는 것은 ‘에러'지만, 음식점을 운영하다 보면 언제나 발생할 수 있는 일이며, 고치는 것이 아니라 다만 대응할 뿐이다. 티켓 없는 입장객도 ‘에러'지만, 극장을 운영하다보면 언제나 일어나는 일이며, 매뉴얼에 따라 대응하면 그 뿐이다.
  서비스도 마찬가지다. 서비스를 운영하다보면 인증 에러, 잘못된 페이지에 접근하는 에러 등은 언제나 발생하며, 고치는 것이 아니라 ‘적절하게 핸들링'하는 것이 관건이다.

- **버그: 허점, 혹은 사고 Programming Errors**
  ![bomb_2](../references/draft/error_handling/bomb_2.png)

  프로그래밍상 에러는 ‘버그’다. ‘고장난’ 것이며, 발견 즉시 ‘고쳐져야' 한다. 프로그래밍 문법 버그, 보안상 위험, 혹은 서버, 데이터베이스 장애 등이 이에 해당한다.
  미리 발견하고 고쳤다면 미리 메워진 빈틈에 그치지만, 놓쳤다면 사고가 난다. ‘cors’를 미리 구체적으로 세심하게 설정했다면 리스크는 해결된 것이지만, cors를 ‘\*’로 설정했다가 보안이 뚫린다면? 리스크는 사고가 된다. 예상보다 트래픽이 폭주한다면? 서버가 터진다.
  버그는 최대한 미리 발견하고 미리 차단하는 것이 가장 중요하다. 사고가 이미 발생했을 때는 늦었다. (이미 사고가 발생했다면, 터뜨리는 것이 낫다. 억지로 막다가는 더 큰 사고로 이어질 수 있다. 왜 그런지는 아래서 알아보자.)
  물론 모든 위험을 전부 다 막는 것은 불가능하다. 최고 전문가들로 가득한 AWS, 애플 등 거대 기업등도 당했다는 Log4J 사태만 봐도 그렇다. 다만 최대한 노력할 뿐이다.
  ![graphs_1](../references/draft/error_handling/graphs_1.png)

  즉, 우리가 혼용해서 쓰는 ‘에러'는 운영상, 일상적으로 발생하는 에러(Operational Errors)와 버그(Programming Errors)로 구분할 수 있고, 각각 다르게 대처해야 한다. 전자는 발생하면 대응하고, 후자는 발생하기 전에 고친다.

### 이제, 에러를 다시 분류해보자

![graphs_2](../references/draft/error_handling/graphs_2.png)

1. **운영상 에러 Operational Errors**

   - 해결 가능한 에러 vs 해결 불가능한 에러
       <aside>
       💡 “마주한 에러를, 사용자 스스로 해결 가능한가, 불가능한가?”
       [*클라이언트의 사용자 중심 예외 처리 >>*](https://jbee.io/react/error-declarative-handling-2/)
       
       </aside>
       
       운영상 에러는 다시 ‘해결 가능한가’로 분류할 수 있다. 에러에 대해, 사용자에게 해결 가이드를 주고, 사용자가 계속 서비스를 사용할 수 있다면 ‘해결 가능한 에러’다.

   1. **해결 가능한 운영상 에러**
      - HTTP 상태코드로 정의된 에러
        ex) 인증 실패로 인한 401, 잘못된 페이지 접근으로 인한 404 등
      - 비즈니스 로직상 정의된 에러
        ex) 회원가입 시 유저의 아이디/비밀번호가 사이트 규칙에 맞지 않는 경우,
        데이터 constraint에 맞지 않는 경우,
        포인트 결제를 하는데 잔액이 부족한 경우 등
      - 기타
        상황에 따라 같은 에러를 운영상 에러로 볼 수도, 프로그래밍상 버그로도 볼 수도 있다.
        ex) requeste timeout, 서버 과부화로 인한 503 에러 등\*
   2. **해결 불가능한 운영상 에러**

      주로 서비스 주체(서버/클라이언트)의 문제가 아닌, 외부에서 발생하는 에러. 운영상 언제나 마주칠 수 있지만, 외부에서 발생했기 때문에 해결할 수 있는 방법은 없다.

      - 서드파티 에러
        ex) 오픈 API 호출 에러, AWS 같은 클라우드 서비스 에러 등
      - 일시적인 네트워크 장애
      - 사용자 브라우저 장애

2. **프로그래밍상 버그 Programming Errors**

   - 해결 가능한 에러 vs 해결 불가능한 에러
       <aside>
       💡 “사전에 해결(혹은 방지)했는가? 하지 못했는가”
       
       </aside>
       
       프로그래밍상 버그는 최대한 사전에 해결 혹은 방지해야 한다. 기본적인 보안상 위험에 대해, 미리 보안책을 마련하고, 기본적인 트래픽 규모를 예상해 서버를 대비하고, 철저한 테스트를 통해 버그를 미리 고쳐야 한다.
       
       <aside>
       💡 이 에러들은 사전 그대로 그냥 ‘버그'다.  우리는 합법적인 시스템이나 네트워크 실패가 아닌 ‘실제 버그'에 대해서 이야기하고 있는 것이다. 프로그램에 있어서는 안 되고, 최우선순위는 디버깅하고 고쳐야 하는 버그 말이다.
       By definition, these errors are *always* bugs. We’re not talking about legitimate system or network failures, but actual bugs in the program. They should be rare in production, and the top priority has to be to debug and fix them.
       [*Error Handling in Node.js >>*](https://www.joyent.com/node-js/production/design/errors)
       
       </aside>
       
       물론, 위에서 말했듯이, 모든 것을 완벽하게 막는 것을 불가능하다. 유튜브도 터지고, AWS도 터진다. 최근 역사상 최악의 보안 사태로 등장한 Log4j사태만 봐도 공룡 기업들이 다 당했다. 최대한 노력할 뿐이다.

   1. **미리 해결한 프로그래밍상 버그**
      - 보안 위험
        ex) javascript를 통한 공격을 적절한 cors 설정으로 차단, 비밀키/데이터베이스 암호를 .gitignore파일로 분리하여 접근 차단 등
      - 서버, 데이터베이스 장애 등
        ex) 티케팅에 대해, 미리 사람이 몰릴 것을 예상하여 서버 대응책을 잘 마련해놓은 경우
      - 프로그래밍 문법상 버그
        프로그래밍 문법상 버그는 당연히 사전 테스트로 디버깅된다고 생각하기 쉽지만, 코드가 길어지거나, 혹은 코드 품질로 인한 동작 속도 문제는 사전에 발견하기 어려울 수도 있다. 이를 사전에 최대한 찾아내는 것이 중요하다.
        ex) Query 실행 계획을 점검하여, N+1 문제를 발견, 서버가 과부하를 막은 사례
   2. **미리 해결하지 못한 프로그래밍상 버그**
      - 보안 위험
        ex) 최근 발생한 Log4J 사태 등
      - 서버, 데이터베이스 장애 등
        ex) 예상보다 서버 트래픽이 폭주하여 서버가 ‘터져버린' 경우
      - 프로그래밍 문법상 버그

## 🧐에러, **어떻게 핸들링해야 할까?**

에러들을 특성에 따라 분류했으니 이제 에러들마다 적절하게 핸들링하는 방법을 찾아보자.

![graphs_3](../references/draft/error_handling/graphs_3.png)

- 전반적인 원칙
  - **정답은 없다. 상황에 따라 대처한다**
    에러 분류에 따라 대략적인 방향을 제시하기는 했지만, 무조건 그렇게 대처해야 한다는 것은 아니다. 정답은 없다. 상황에 따라 가장 맞는 대처를 해야 한다.
    HTTP상태 코드로 정의된 에러라 해도, 바로 해결할 수 없다고 판단되면 터뜨려버릴 수도 있다.
    반대로 서버 문제라 해도, 일시적인 서버 과부하로, 다시 시도해도 된다고 판단되면 다시 요청을 시도할 수도 있다. 상황에 따라 request timeout, 500번대 에러 등은 바로 해결할 수도, 그냥 터뜨려버려야 할 수도 있는 것이다.
  - **언제나 로그를 남기고 모니터링한다**
    시스템을 아무리 꼼꼼하게 검증했다 하더라도 언제나 위험은 있을 수 있다. 따라서, 로그를 남기고 꾸준히 모니터링하는 것은 필수다. 특히, 예상치 못한 사고-버그가 터졌을 때, ASAP으로 고쳐야 할 때, 로깅을 통해 빠르게 발견하고 원인을 추적해서 수정할 수 있다.

1. 운영상 에러 Operational Errors

   1. **해결 가능한 운영상 에러**

      **→ 유저에게 해결 가이드를 제시한다**

      운영상 에러는 유저에게 해결 가이드를 제시하고, 유저가 이탈하지 않고 계속 서비스를 이용하게 유도할 수 있다. 마치 가게 주인이 안내를 하는 것처럼 말이다.

   ![error_types_1](../references/draft/error_handling/error_types_1.png)

   백엔드에서 상태코드를 던져주면, 프런트는 각각의 상태코드에 맞게 유저에게 메세지를 전달하고, 유저는 메세지에 따라 서비스를 계속 이용할 수 있다.

   ![error_types_2](../references/draft/error_handling/error_types_2.png)

2. **해결 불가능한 운영상 에러**

   **→ 에러가 전파되지 않게 한다**

   우리가 주체가 아닌 에러, 외부에 의존하는 에러는 우리가 해결할 수 없다. 우리가 할 수 있는 최선은 해당 에러의 영향 범위를 제한해서, 에러가 전파되지 않게 하는 것이다.

   예를 들어, 한 화면에서 10개의 오픈 API를 호출하는데, 그 중 1개 API가 실패했다고 해서, 페이지 전체를 에러 처리 해버릴 필요는 없다. 일단 페이지를 띄우고, 해당 API 영역에 대해서만 실패 처리하고 복구를 시도하면 된다.

3. 프로그래밍상 버그 Programming Errors

   1. **미리 해결한 프로그래밍상 버그**

      **→ 최대한 사전에 디버깅, 차단, 혹은 방지한다**

      여러번 반복해 말한 것처럼, 최대한 사전에 미리 디버깅, 차단, 혹은 방지해야 한다. 그러려면 보안상 위험이나 서버, 데이터베이스의 동작 원리에 대해 잘 알고, 발생할 수 있는 리스크들에 대해서도 미리 파악하고 있어야 할 것이다.

   2. **미리 해결하지 못한 프로그래밍상 버그**

      **→ 로그를 남기고, 터뜨린다**

      에러를 꼭 모두 핸들링해야 하는 것은 아니다. 어떤 에러는, 특히 고장난 버그라면 터뜨려야 할 수도 있다. 어떤 식으로든 에러를 catch해 액션을 취할 수도 있겠지만, 에러를 숨기는 것에 불과하다. 물론 ‘사고'가 발생하는 것이지만, 이를 억지로 핸들링하려다가 오히려 더 큰 위험을 숨겼다 나중에 빵 터져버리는 것이 될 수도 있다.

      ex) Restful하게 통신을 할 때, 잘못 입력한 변수 이름으로 인한 ReferenceError가 발생했다고 해보자. 억지로 에러를 예외 처리하고, 숨긴다 해도 더 심각한 문제가 생길 수 있다.

      [_참조. Error Handling in Node.js >>_](https://www.joyent.com/node-js/production/design/errors)

      - 요청의 일부가 null, defined이거나, 혹은 다른 이유로 유효하지 않다면, 다음 요청도 어차피 똑같이 실패하게 되어 있다.
      - 실패한 요청으로 인해 데이터베이스 커넥션이 열린채로 누수되면, 이후에 동시에 처리할 수 있는 요청의 개수가 줄어들 수 있다. 극단적으로는 커넥션이 몇개 밖에 안남아, 동시 처리가 불가능해지는 사태가 발생할 수도 있다.
      - 심지어, postgres connection이 transaction이 열려 있는 채로 안에 남아있을 수도 있다. 이렇게 되면 postgres는 옛날 버전의 데이터 행들에 의존하게 된다.(이 트랜잭션에서 보이는 것은 옛날 버전 데이터 행들이므로) 이 상태로 며칠, 혹은 몇 주를 가게 되고, 테이블 규모가 겉잡을 수 없이 커져서 - 이후 쿼리들의 속도가 매우 느려질 수도 있다. 물론 이 케이스는 postgres에 한정된 것이긴 하지만, 아무리 작은 고장(버그)라도, 프로그램의 ‘고장'(버그)를 터뜨리는 게 아니라 숨겼을 경우에 얼마나 심각한 문제가 발생할 수 있는지 보여준다.

      → 로그를 통해 고친다

      이런 경우, ‘로그'가 특히 더 중요하다. 예상치 못한 곳에서 예상치 못하게 에러가 터졌다면, 로그를 통해 빠르게 원인을 추적하고 고쳐야 한다. 소 잃고 외양간 고치기로 볼 수도 있겠지만, 소를 잃었어도 외양간을 고쳐야 다음 소를 받을 수 있지 않겠는가.

## 🧐결론

에러 핸들링을 나름대로 정리해보니 에러 핸들링을 어떻게 해야 할지 감을 잡을 수 있었다.

다만 아쉬운 것은 대부분의 정보들이 ‘클라이언트'의 역할, 그리고 error 캐치를 하는 문법 예제에 초점이 맞춰져 있었다는 것이었다. 백엔드에서의 에러 핸들링은 정보가 턱없이 부족했다. 앞으로는 백엔드 공부를 하면서 직접 경험했던 에러들, 백엔드의 역할에 대해 하나씩 정리해보려고 한다.

또한, 단순 기능 구현에 따른 에러들, HTTP 상태 코드로 정의하는 에러들은 코드를 쳐보며 쉽게 이해할 수 있었지만, 서버 장애, 데이터베이스 장애, 네트워크 장애와 관련된 에러들은 아무래도 경험치가 부족하다보니, 감을 잡기 어려웠다. 처리 방법은 커녕, “대체 어떤 상황에서 장애가 발생하는걸까?” 하는 문제 상황부터 떠오르지 않았다. 앞으로 경험치를 쌓아가며 서버 장애, 데이터 베이스 장애 상황들에 대해서도 하나씩 정리해나가고자 한다.

- 참고
  [_클라이언트의 사용자 중심 예외 처리 >>_](https://jbee.io/react/error-declarative-handling-2/)
  [_Error Handling in Node.js>>_](https://www.joyent.com/node-js/production/design/errors)
