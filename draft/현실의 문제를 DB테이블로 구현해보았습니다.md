# 현실의 문제를 DB테이블로 구현해보았습니다

# 🧐 현실의 문제를 DB테이블로 구현해보자

이전 글에서는 데이터 모델링 이론을 정리했다. [_데이터 모델링, 왜 중요할까? >>_](https://www.notion.so/e4e665e04151498d975b920628faa8f3?pvs=21)

그런데 정작 이론을 실전에 적용할 수가 없었다. 이론은 이론대로, 실전은 실전대로 따로 노는 느낌이었다. **결국 궁극적인 목적은 현실의 문제를 DB테이블로 구현하는 것인데**, 실전에 적용할 수 없으면 말짱 꽝이다.🤢

![taling_logo](../references/draft/realworld_database/taling_logo.png)

그래서 대표적인 재능 공유 플랫폼인 탈잉을 데이터 모델링 해보기로 했다.

# 🙌  실전 데이터 모델링 결과

<!-- modeling html--> (../references/draft/realworld_database/taling_modeling.html)

![taling_modeling](../references/draft/realworld_database/taling_modeling.png)

# 🙌 실전 데이터 모델링을 해보자

## 🤔 어떻게?

공부한 방법론을 실전에 적용해보자.

<aside>
💡 1. 도메인 구조를 파악한다
2. 도메인 구조를 반영해 테이블 구조를 설계한다
3. 이상 현상을 막기 위해 정규화를 통해 테이블을 쪼갠다.
4. 실제 운영의 편의성을 고려해 테이블을 쪼개고 합친다

</aside>

자세한 내용은 이전 글 참조. [_데이터 모델링, 왜 중요할까? >>_](https://www.notion.so/e4e665e04151498d975b920628faa8f3?pvs=21)

## 1. 도메인 구조를 파악하고, 큰 그림을 설계해보자

### ☑️ 도메인 구조를 파악한다

- **서비스에 필요한 도메인, 도메인의 속성, 도메인 간의 관계를 파악한다**
- **도메인 속성을 파악해, 필요하다면 도메인을 더 세부적으로 분해한다.**

  - **도메인 간의 관계**
    ![taling_domain](../references/draft/realworld_database/taling_domain.png)

  - **도메인 별 속성**
    ![taling_domain_properties](../references/draft/realworld_database/taling_domain_properties.png)

### ☑️ 도메인 구조를 반영해 테이블을 설계한다

- **도메인 → 테이블**
- **도메인 간의 관계 → 테이블간의 관계**
- **도메인의 속성 → 테이블의 칼럼**

하나의 도메인을 하나의 테이블로, 도메인의 속성을 테이블의 칼럼으로 테이블 스키마를 설계한다.

도메인간의 관계를 반영해 테이블간의 관계를 설계한다.

테이블을 설계하는 과정에서 도메인을 파악하고, 파악한 도메인을 다시 설계에 반영하는 과정을 반복한다.

**[도메인간의 관계 → 테이블간의 관계]**

![taling_domain_relations](../references/draft/realworld_database/taling_domain_relations.png)

**[도메인의 속성 → 테이블의 칼럼]**

![taling_domain_to_table_users](../references/draft/realworld_database/taling_domain_to_table_users.png)

![taling_domain_to_table_classes](../references/draft/realworld_database/taling_domain_to_table_classes.png)

## 2. **도메인 별로 상세 설계를 해보자**

### ☑️ 이상 현상을 막기 위해 정규화를 적용해 테이블을 쪼갠다.

### ☑️ 실제 운영의 편의성을 고려해 테이블을 쪼개고 합친다

1. **유저 도메인**

   - **정규화를 적용해 유저 테이블과 이력 테이블을 분해한다.**
     **문제 상황**
     유저 테이블의 기본키를 (유저번호+이력 제목)으로 설정하면, 기본키에 완전함수종속되지 않는 속성이 생긴다.(제 2 정규화를 만족하지 못함) 그렇다고 기본키를 (유저번호)로만 설정하면, 기본키에 종속되지 않는 속성이 생긴다.
     **해결 방법**
     (유저번호)를 기본키로 하는 '유저 테이블'과, (유저번호+이력제목)를 기본키로 하는 '이력 테이블'을 분해한다.

     - (유저번호) → 계정, 비밀번호, 이름, 별명 ...
     - (유저번호+이력제목) → 이력 내용, 이력 이미지 ...
       ![normalization_users_1_1](../references/draft/realworld_database/normalization_users_1_1.png)

       **해결 과정**
       실제로 **1) 데이터를 표로 그려보고, 2) 이상 현상이 발생하는가? 고민해보면** 쉽게 오류를 잡아내고 설계를 할 수 있다.
       **1) 데이터를 표로 그려보자**
       ![normalization_users_1_2](../references/draft/realworld_database/normalization_users_1_2.png)

       처음 유저 테이블을 보면, 유저번호, 유저 별명, 유저 계정 등 **데이터 행이 중복으로 존재한다**. 한 유저에게 이력이 여러 개 있기 때문에, **즉 유저 : 이력이 1:M관계이기 때문에,** 모든 이력을 다 표시하기 위해서는 어쩔 수 없다.
       **2) 이상 현상이 발생하는가? 고민해보자**
       ![normalization_users_1_3](../references/draft/realworld_database/normalization_users_1_3.png)

       이렇게 데이터 행이 중복인 상태에서 데이터 행을 하나만 수정할 경우, 한 유저에 대한 데이터가 서로 불일치하는 수정 이상이 발생할 수 있다.
       **3) 그러면, 테이블을 분해하면 되지 않을까?**

     - 1:M 관계 → 데이터 행이 중복 → 데이터 불일치가 발생하지 않을까? → 테이블을 분해한다.
       ![normalization_users_1_4](../references/draft/realworld_database/normalization_users_1_4.png)

       **결론**
       데이터 정규화 과정은 이론적으로 접근하는 것보다는, **1) 실제 데이터를 표로 그려보고, 2) 이상 현상이 발생하는가? 고민하는 것**이 더 쉽고 빈틈을 놓치지 않을 수 있다.
       유저 테이블 분해 과정 역시, '제 2 정규화 원칙에 따라 정규화 한다'는 이론적 접근을 하기 보다는, 1) 실제 유저 데이터를 표로 그려 유저 ↔ 이력은 1:M 관계라는 것을 파악하고, 2) 유저 데이터가 중복으로 있으면 데이터 불일치가 생길 위험이 있다는 것을 파악하면 설계 오류를 더 쉽게 잡아낼 수 있다.
       ![normalization_users_1_5](../references/draft/realworld_database/normalization_users_1_5.png)
       실전에서 제 2 정규화를 적용해야 하는 케이스 중 하나가 유저 테이블 분해 예시와 같은 케이스이다. 즉, 도메인과 연관된 하위 도메인이 1:M 관계인 경우, 제 2 정규화가 발생할 경우가 많다. 따라서, '제 2정규화를 하자'고 생각하기 보다는, '1:M' 관계는 분해하자'를 먼저 생각하는 것이 편하다.
       ex. 게시물 테이블 : 게시물 이미지 테이블 = 1 : M
       ex. 클래스 테이블 - 클래스 세션 테이블 = 1 : M

   - **도메인 속성을 고려해 유저(튜터), 유저(수강생), 유저(관리자) 도메인을 '유저' 도메인으로 합친다.**
     플랫폼에는 소비자 유저와 생산자 유저가 있고, 소비자가 생산자가 될 수도, 생산자가 소비자가 될 수도 있다. 플랫폼의 비즈니스 로직에 따라 소비자와 생산자를 한 도메인으로 볼 수도, 각각 다른 도메인으로 볼 수도 있다.
     탈잉의 경우, '튜터'와 '수강생'이 존재하는데, 도메인의 속성을 나열해보면, 1~2개 속성을 제외하고는 모든 속성이 동일하여 큰 차이가 없다. 그렇다면, 1) '유저' 테이블을 하나로 묶고, 2) 유저 타입 테이블을 따로 두는 대신 '튜터 여부'만 T/F로 구분하는 것이 운영상 편리하다고 판단했다.
     만약 유저별로 속성이 많이 다르다면, 테이블을 따로 두는 것이 운영에 더 편할 것이다. 실제로 이전 인턴때 참여한 맛집 플랫폼 프로젝트에서는 소비자 테이블과, 가게주인 테이블이 속성이 전혀 달라 각각 별도의 테이블을 두었다.
     또, 아래에도 다시 나오지만, 탈잉의 핵심 컨텐츠인 '클래스'는 클래스라는 하나의 도메인처럼 보였지만 두개의 도메인으로 설정했다. 속성을 살펴보니 일반 클래스와 VOD 클래스의 속성이 전혀 달랐고, 두개의 도메인으로 쪼갤 수 밖에 없었기 때문이다.
     도메인이 하나인가? 혹은 두 개, 세 개인가?의 문제는 정해진 것이 없는 것 같다. 고정적으로 생각하기보다, 서비스의 구조에 따라 적절하게 결정해야 한다.
     **[도메인] 유저(수강생), 유저(튜터), 유저(관리자) → 유저(통합)**
     ![normalization_users_2_1](../references/draft/realworld_database/normalization_users_2_1.png)
     **[스키마] 유저(수강생), 유저(튜터), 유저(관리자) → 유저(통합)**
     ![normalization_users_2_2](../references/draft/realworld_database/normalization_users_2_2.png)
     [테이블]유저 테이블 통합

2. **클래스 도메인**

   - **큰 그림을 세부 도메인으로 분해한다.(클래스 → 클래스, 진행방식, 진행상태 등)**
     서비스의 큰 그림을 그려보면, 아래와 같이 **클래스** 도메인이 있다.
     ![taling_domain_relations](../references/draft/realworld_database/taling_domain_relations.png)

     실제 테이블을 설계하는 단계에 들어가면, 클래스라는 도메인의 속성을 하나하나 나열해 보고, 단순한 속성이 아닌 별도의 도메인으로 봐야 하는 것들을 세부 도메인으로 분해해야 한다.
     **[세부 도메인 분해]**
     ![normalization_classes_1_1](../references/draft/realworld_database/normalization_classes_1_1.png)

     강의 횟수, 진행 방식, 참여 인원, 진행 상태 등은 클래스의 속성이기도 하지만, 서비스의 비즈니스 로직상 하나의 도메인이다. 비즈니스 상으로 몇 가지 타입을 고심하여 정해놓고, 클래스는 그 중 한 가지 타입을 선택하는 것이기 때문이다.
     '진행 방식'을 예로 살펴 보자. 탈잉은 비즈니스적으로 오프라인/온라인Live/VOD/전자책/녹화영상 클래스를 운영한다. 이건 탈잉의 [클래스 진행 방식]이라는 하나의 도메인이다.
     새로운 오프라인 클래스를 개설해 DB에 저장한다고 해보자. '오프라인' 타입이라는 게 존재하는지 어떻게 알 수 있을까? 코딩에 '오프라인'으로 하드코딩을 해놓아야 할까? 아니면 클래스 전체 테이블을 훑으며 '오프라인' 이라는 이름을 찾은 후 복사해서 저장해야 할까? 만약 실수가 생겨 일부는 '오프라인', 일부는 '대면클래스'라고 저장이 된다면? 만약 오프라인과 온라인으로 필터링을 걸었는데 '대면클래스'는 다 빠져버린다면?
     혹은 채팅 멘토링'이라는 새로운 클래스를 도입한다고 해보자. 클래스가 아직 하나도 개설되지 않았어도, '채팅 멘토링'이라는 타입이 있다는 사실은 [클래스 진행 방식] 테이블에 저장된다. 만약 [클래스] 테이블에 저장한다면, 아직 새로운 클래스가 하나도 없는데도 불구하고 '진행방식' 칼럼 외에 다른 칼럼을 모두 NULL로 저장해야 한다.
     도메인 구조상으로도, 또 실제 운영상으로도 [클래스 진행 방식]을 별도의 테이블로 두는 것이 데이터 상 안전하고 또 효율적이다. 이처럼 컨텐츠에 대해 정해진 몇 가지 타입 중 한 가지를 택해야 할 경우, [타입] 도메인으로 보고 별도의 테이블을 만든 후, [컨텐츠] 테이블과 [타입] 테이블을 서로 연결해야 한다.
     ![normalization_classes_1_2](../references/draft/realworld_database/normalization_classes_1_2.png)

   - **운영의 편의성을 고려해 한 도메인도 여러 테이블로 분해한다.( 클래스 → 클래스 + 클래스 소개글)**
     하나의 클래스 도메인이라도, 운영의 편의성을 위해 테이블을 분해할 수도 있다.
     탈잉 클래스에서 카테고리, 클래스 타입 등 다른 값은 크게 바뀌는 경우가 많이 없지만, [소개글] 값은 튜터들이 자주 수정할 것이라 생각했다. 그래서 1:1 관계이고, 구조상 [테이블] 테이블에 두어도 무방하지만, 안전하고 효율적인 관리를 위해 두개의 테이블을 분해했다.
     물론 테이블을 분해할 경우, 데이터를 조회할 때 JOIN으로 비용을 써야 하기 때문에 장단점이 있다. **테이블을 분리하여 데이터 저장의 효율과 안전을 택할 것인가 vs 한 테이블에 두고 JOIN 없이 효율적인 데이터 조회를 택할 것인가**, 운영상 목표에 따라 선택해야 한다.
     **[클래스(도메인) → 클래스(테이블), 클래스 소개글(테이블)]**
     ![normalization_classes_2_1](../references/draft/realworld_database/normalization_classes_2_1.png)

     ![normalization_classes_2_2](../references/draft/realworld_database/normalization_classes_2_2.png)

   - **비슷해보여도 속성이 다르면 각각의 도메인으로 분리한다.(클래스 → 클래스(일반), 클래스(VOD))**
     '클래스'라는 하나의 도메인처럼 보이지만 두개의 도메인으로 설정했다. 속성을 살펴보니 일반 클래스와 VOD 클래스의 속성이 전혀 달라, 각각 다른 도메인으로 판단했기 때문이다. 유저 도메인에서 유저(튜터), 유저(수강생), 유저(관리자)를 하나의 도메인으로 합친 것과는 반대의 케이스다.
     **[클래스(일반) vs 클래스(VOD)]**
     ![normalization_classes_3_1](../references/draft/realworld_database/normalization_classes_3_1.png)

     두 클래스가 관리해야 하는 속성들이 다르다. 특히, 소개글의 형식이 매우 달랐는데, 일반 클래스는 소개글이 텍스트, VOD 클래스는 HTML이었다. 실제 탈잉 서비스를 살펴보면, 일반 클래스의 경우 개인 튜터가 동일한 인풋창에 단순 텍스트를 입력하는 형식이라면, VOD 클래스는 각각의 VOD를 관리자가 직접 맞춤 HTML 소개 페이지를 만드는 형식이었다. 속성들이 매우 달라질 수 밖에 없다.
     이 속성들을 전부 칼럼으로 두고 NULL로 관리하는 것보다, 테이블을 분리하는 것이 더 깔끔하다고 판단했다.
     **[클래스(일반) 구조 vs 클래스(VOD) 구조]**
     ![normalization_classes_3_2](../references/draft/realworld_database/normalization_classes_3_2.png)

     게다가, 데이터 구조가 클래스의 특성상, 일반 클래스는 같은 클래스를 여러 번 반복해서 진행하기 때문에, 이를 1:M관계 [클래스 내역]으로 관리해줘야 하는 반면, VOD 클래스는 온라인 영상을 누구나 시청하는 것이기 때문에 클래스 내역이라는 것이 존재하지 않는다.
     데이터 구조가 너무 다르기 때문에, 테이블을 각각 두는 것이 구조상 더 체계적이라고 판단했다.

3. **수강 도메인**
   - **큰 그림을 세부 도메인으로 분해한다.(수강 내역 → 수강 내역, 결제 내역, 환불 내역)**
     수강 내역도 역시 세부 도메인인 수강 내역, 결제 내역, 환불 내역으로 분해했다.
     가장 큰 고민은 환불 내역이었다. 환불 내역을 분리해야 할까? 관점에 따라 결제 내역에 환불 내역을 둘 수도, 따로 분리할 수도 있다. 결국 환불 내역을 별도 테이블로 분리하기로 했는데, 1) 환불 내역과 관련된 속성들이 워낙 많고(환불 방법, 환불액, 환불액 중 수수료, 등등), 2) 결제 데이터 중 일부에만 환불 데이터가 있기 때문이었다.
     결제 데이터 중 일부에만 환불 데이터가 있고, 즉 결제 데이터 대부분은 환불 데이터가 없기 때문에, 대부분의 데이터에 필요없는 많은 칼럼들을 NULL값으로 두는 것보다 테이블을 분리하는 것이 효율적이라고 판단했다.
     **[수강 내역, 결제 내역, 환불 내역]**
     ![normalization_registrations_1_1](../references/draft/realworld_database/normalization_registrations_1_1.png)

# 🙌 결론

**1. 도메인 구조를 파악한다**

- 서비스에 필요한 도메인, 도메인의 속성, 도메인 간의 관계를 파악한다
- 도메인 속성을 파악해, 필요하다면 도메인을 더 세부적으로 분해한다

**2. 도메인 구조를 반영해 테이블 구조를 설계한다**

- 도메인 → 테이블
- 도메인 간의 관계 → 테이블간의 관계
- 도메인의 속성 → 테이블의 칼럼
  - 비슷해보여도 도메인의 속성이 다르면 각각의 도메인으로 분리하고, 혹은 달라보여도 속성이 비슷하다면 하나의 도메인으로 묶을 수 있다.
  - 테이블을 설계하는 과정에서 도메인을 파악하고, 파악한 도메인을 다시 설계에 반영하는 과정을 반복한다.

**3. 이상 현상을 막기 위해 정규화를 통해 테이블을 쪼갠다**

- 1. 실제 데이터를 표로 그려보고, 2) 이상 현상이 발생하는가? 고민하고, 정규화를 적용한다.

**4. 실제 운영의 편의성을 고려해 테이블을 쪼개고 합친다**

- 운영의 편의성을 고려해 하나의 도메인 중 일부만 매우 자주 수정된다면, 바뀔 일이 없는 데이터와, 자주 수정되는 데이터를 테이블 분리한다.
- 정규화가 필요해도, 자주 묶어서 조회/수정해야 하는 데이터라면 정규화하지 않고 한 테이블에 묶어둘 수도 있다.
