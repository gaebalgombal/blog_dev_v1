# 객체의 역할, 책임 협업

# 🧐 왜 객체 지향적 설계를 하려고 했을까?

❗\***\*유연하고 확장성이 좋은 코드를 통해, 빠르게 변화에 대응하는 것이 목표\*\***

1. 의존성 분리

   비즈니스 로직, 요청을 받고 응답을 처리하는 로직, DB를 조작하는 책임을 분리하고, 각각의 작은 객체에 역할을 맡기고, 서로 협업하도록 했다. 각각의 객체를 호출하여 사용하면 되기 때문에, 유연하고 빠르게 변화에 대응할 수 있다.

2. 대량의 반복 작업을 캡슐화

   raw SQL로 작업할 경우, 수십 줄의 SQL문을 실행해야 한다. 만약 칼럼명이라도 변경된다면 일일이 찾아보며 수정을 해야하기 때문에 오류가 발생할 수 있다.

   때문에 View 객체에서 DB 스키마를 선언만 하고 Serializer 객체를 호출하면, Serializer 객체가 SQL 작업하는 책임을 지도록 했다. 어떤 DB 스키마를 선언하던 Serializer가 ‘알아서' SQL작업을 하기 때문에 역시 유연하고 빠르게 변화에 대응할 수 있다.

# 🧐 어떻게 객체 지향적으로 설계했는가?

## 📦 객체간의 협업 구조

![oop_relation](../../references/draft/2022.02_catch/oop/oop_relation.png)

- Urls
  요청 URL ↔ View 객체의 맵핑하고 적절한 View 객체를 호출하는 역할
- View 객체
  클라이언트의 요청에 따라 적절한 Serializer 객체를 호출하고,
  반환값을 클라이언트에게 응답으로 반환하는 역할
- Serializer 객체
  View객체의 요청에 따라 SQL문을 작성하고, DB를 호출하고,
  반환값을 다시 View 객체에게 반환하는 역할

## 📦 객체간의 상속 구조

![oop_inheritance](../../references/draft/2022.02_catch/oop/oop_inheritance.png)

- BaseSQLSerializer (인터페이스 객체)
  인터페이스를 정의
- SimpleSQLSerializer (내부메소드 객체)
  인터페이스를 내부 메소드로 구현
- JobSerializer, CompanySerializer, •••••• (비즈니스 로직 객체)
  도메인(DB 스키마)를 선언하고, 내부 메소드를 호출하여 처리

## 📦 정말 유연하고 확장성이 좋을까?

이제 시스템은 아래와 같이 객체간의 협업을 통해 작동한다.

<aside>
📁 1. 도메인에 따라 도메인 Serializer 객체를 선언하고,
2. View 객체에서 Serializer의 외부 인터페이스를 호출하면
3. Serializer 객체의 캡슐화된 내부에서 알아서 SQL작업을 처리한다.

</aside>

❗따라서 어떤 도메인이든 DB 스키마를 선언하고 Serializer 객체만 호출하면 처리할 수 있고(확장성),

변경할 때 역시 선언된 DB 스키마를 한 번만 바꾸면 된다(유연함)
